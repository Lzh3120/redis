# 锁

InnoDB支持表锁和行锁，默认行锁。行锁粒度小，性能消耗大

## 表锁&行锁

表锁：mysql中锁定粒度最大的一种锁，针对非索引字段加锁，对当前整张表加锁，资源消耗少，加锁快，不会出现死锁。锁定粒度最大，触发锁冲突概率最高，并发度最低。MyISAM和InnoDB都支持表级锁。

行锁：mysql中粒度最小的一种锁，针对索引字段加的锁，只针对当前操作的记录进行加锁。行锁可以大大减少数据库操作的冲突。锁定粒度最小，并发度最高，但加锁开销最大，加锁慢，会出现死锁。

## 共享锁和排他锁

共享锁（S锁）：事务读取数据时获取的锁，允许多个事务同时获取。

排他锁（X锁）：又称写锁，事务在修改记录时获取的排他锁，不允许多个事务同时获取。

|S锁|X锁
-|-|-
S锁|不冲突|冲突
X锁|冲突|冲突

由于MVCC的存在，一般的Select语句，不会加任何锁。可以通过语句显式加锁：
1. 共享锁：select ... lock in share mode;
2. 排他锁：select ... for update;

意向锁有什么用？

如果用到表锁，如何判断记录有没有行锁，这时候就要用意向锁来快速判断是否可以对某个表使用表锁。

1. 意向共享锁（IS锁）：事务有意对表中的某些记录加共享锁，加共享锁（S锁）前必须先取得该表的意向共享锁（IS锁）。
2. 意向排他锁（IX锁）：事务有意向表中某些记录加排他锁，加排他锁之前必须先取得该表的意向排他锁（IX锁）
3. 意向锁之间是互相兼容的。

|IS锁|IX锁
-|-|-
S锁|兼容|互斥
X锁|互斥|互斥

InnoDB支持三种锁定方式
1. 记录锁（Record Lock）：记录锁，属于单个行记录上的锁
2. 间隙锁（Gap Lock）：锁定一个范围，不包括记录本身
3. 临建锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包括记录本身。

InnoDB默认隔离级别（可重复读）解决幻读，以下情况：
1. 快照读：由MVCC机制保证不出现幻读
2. 当前读：使用Next-Key Lock进行加锁，保证不出现幻读

快照读：

就是单纯的select语句，不包括显式加锁。快照读就是读取历史数据，每行记录可能存在多个版本。快照读时，如果读取的数据正在进行update，delete操作，读取操作不会去等待记录上的X锁，而是去读取行的一个快照。
1. RC（读已提交）级别下，快照读读取的时锁定行的最新的一份快照数据
2. RR（可重复读）级别下，快照读，读取的时事务开始时的数据行版本

当前读：

for update，lock in share mode，insert，update，delete

