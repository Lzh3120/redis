# 垃圾收集器

## 对象是否需要回收
1. 引用计数算法
2. 可达性分析算法

### 引用技术算法

给对象中添加一个引用计数器，当有一个对象引用时，计数器就+1，引用失效时，计数器就减1，计数为0的对象就是不再被使用。

无法解决循环引用的问题。

### 可达性分析算法

通过一系列为 GC Root 的对象作为起始点，从这些点向下搜索，搜索所走过的路径称为引用链。当一个对象到达GC Root没有引用链时，说明对象不可用了。

可作为GC Root的对象：
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象

## 垃圾收集算法
1. 标记-清除算法
2. 复制算法
3. 标记-整理算法
4. 分代收集算法

### 标记-清除算法
1. 标记阶段：标记出所有需要回收的对象
2. 清除阶段：同一回收所有被标记的对象
3. 存在问题：效率很低，清除后出现大量不连续的内存碎片

### 复制算法
1. 将内存分为大小相等的两块
2. 当一块用完，将存活的对象复制到另一快内存上
3. 把已使用过的内存空间清理掉
4. 存在问题：只能使用一半的内存，代价很高
5. 优化：每次存活的对象很少，不需要一半分。分为Eden：Surivivor=8：1，进行复制

### 标记-整理算法
1. 标记阶段：标记出所有需要回收的对象
2. 整理阶段：将存活的对象都向一端移动，然后直接清理掉端边界意外的内存。

### 分代收集算法
1. 新生代：存活对象少，使用复制算法
2. 老年代：存活对象多，使用标记-清理算法，或者标记-整理算法
