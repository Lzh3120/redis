# 设计模式

## **设计原则**

1. 单一职责原则:一个类只负责一个功能领域中的响应职责
 
2. 开闭原则：一个软件应对扩展开放，对修改关闭
 
3. 里氏代换原则：所有引用父类的地方，必须能透明的使用其子类的对象
 
4. 依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象，即针对接口编程
 
5. 接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应依赖那些它不需要的接口
 
6. 合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的
 
7. 迪米特法则：一个软件实体应尽可能少的与其他实体发生相互作用
 
## **创建型模式**
1. 单例模式：确保某一个类只有一个实例，且自行实例化并向整个系统提供这个实例

[单例模式](创建型模式/单例模式.html)
 
2. 简单工厂模式：定义一个工厂类，通过参数返回不同的实例，通常实例都有公共的父类
 
[简单工厂模式](创建型模式/简单工厂模式.html)

3. 工厂方法模式：定义一个创建对象的接口，让子类决定将哪一个类实例化。将类实例化延迟到子类实现。

[工厂方法模式](创建型模式/工厂方法模式.html)

4. 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

[抽象工厂模式](创建型模式/抽象工厂模式.html)

5. 建造者模式：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示
 
[建造者模式](创建型模式/建造者模式.html)

6. 原型模式

 ### **结构性模式**
 
1. 适配器模式: 使接口不兼容的类可以一起工作，别名为Wrapper

[适配器模式](结构性模式/适配器模式.html)
 
2. 装饰模式：动态给一个对象增加一些额外的职责，就增加对象功能来说，装饰器模式比生成子类更灵活
 
[装饰模式](结构性模式/装饰模式.html)

3. 代理模式：给某一个对象提供一个代理，并由代理控制对原对象的引用。
 
[代理模式](结构性模式/代理模式.html)

4. 桥接模式

5. 组合模式

6. 外观模式

7. 享元模式

### **行为型模式**
 
1. 命令模式：将一个请求包装成一个对象，可用不同请求对客户端进行参数化，对请求排队或记录请求日志，支持撤销操作

[命令模式](行为型模式/命令模式.html)
 
2. 迭代器模式：提供一个方法来访问聚合对象，而不用暴漏这个对象的内部，别名叫游标

[迭代器模式](行为型模式/迭代器模式.html)
 
3. 观察者模式：定义对象之间一对多依赖关系，使得一个对象状态发生改变时，通知关联到的对象

[观察者模式](行为型模式/观察者模式.html)

4. 模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模版方法使得在不改变一个算法的机构，即可重定义该算法

[模板方法模式](行为型模式/模板方法模式.html)

5. 职责链模式

6. 解释器模式

7. 中介者模式

8. 备忘录模式

9. 状态模式

10. 策略模式

11. 访问者模式