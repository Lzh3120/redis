#事务

事务不是天然存在的，目的是为了简化应用层的编程模型

ACID
1. A原子性：在出错中止事务时，将部分完成的写入全部丢弃
2. C一致性：数据从一个状态到达另一个状态，即状态一致性，数据一致性
3. I隔离性：并发的多个事务相互隔离，互不影响
4. D持久性：事务一旦提交，数据即全部写入磁盘，不会再丢失

符合ACID的系统被冠以BASE理论
1. BA基本可用性
2. S软状态
3. E最终一致性

还有CAP理论
1. C一致性
2. A可用性
3. P分区容错性

事务隔离级别：
1. 读未提交：导致脏读，幻读，不可重复度
2. 读已提交：导致幻读，不可重复读，避免脏读
3. 可重复读：导致幻读，避免脏读，不可重复度
4. 可串行化：避免一切问题，严重影响性能

### 事务的对象：单对象or多对象

#### 单对象写入

向数据库写入一个20KB的文档，中途断电，导致数据不一致。

存储引擎对单对象的，单节点层面提供原子性和隔离性，如：
1. 基于日志恢复来实现原子性
2. 对每个对象加锁的方式实现隔离性
3. 某些数据库提供高级的原子操作：如原子自增，比较-设置操作。

可以有效防止多个客户端并发修改同一个对象导致更新丢失问题，单这些并不是通常意义上的事务。

#### 多对象写入

#### 处理错误与中止

出现错误时，重试机制才是中止流程的重点，否则之前的输入都会被抛弃。

但是重试机虽然是一个简单有效的错误处理机制，但并不完美：
1. 事务实际执行完成，但在网络传输时发生意外，会导致重复执行，此时需要应用层保持幂等
2. 如果错误是由于系统负荷引起的，那么重试会导致情况变遭
3. 临时性错误的重试是有意义的，但永久性故障，重试则毫无意义
4. 在数据库之外，事务还产生其他副作用，即使事务中止，这些副作用已生效
5. 客户端重试中发生失败，则无法继续负责重试，则待写入数据会丢失

#### 弱隔离级别

如果两个数据不存在数据依赖，可以安全的并行，则不存在事务。
只有某个事务修改的数据属于另一个事务同时要读取的数据，或者同时要修改的数据，才会引发并发问题。
所以，数据库一直试图通过事务隔离来解决应用开发者隐藏内部的各种并发问题。

事务隔离并不简单，而可串行化会导致性能下降，所以更多数据库倾向于弱的隔离级别。

##### 读已提交
1. 读数据库时，只能看到已成功提交的数据（防止脏读）
2. 写数据库时，只会覆盖已成功提交的数据（防止脏写）

数据库通常采用行级锁防止脏写
也可以采用锁的方式防止脏读，但会影响性能，更多数据库采用多版本数据防止，对数据存在多个版本，事务提交后切换到新版本。

##### 可重复度

不可重复读（读倾斜）为在一个事务内两次读取，读到了不同的值，侧重于新增和删除类更新。

读倾斜在某些场景下不可容忍：
1. 备份数据场景
2. 分析查询与完整性检查场景

快照级别隔离（MVCC）是解决以上问题的关键
1. 快照级别隔离也用写锁防止脏写
2. 采用多版本并发控制（MVCC）防止脏读和不可重复读

表中每一行都有一个创建ID和删除ID，当数据被操作时更新这两个值。

> MVCC的可见性规则
1. 事务开始时，创建该对象的事务已经提交
2. 对象没有被标记为删除，或者即使标记了，但删除事务在当前事务开始时还没有完成提交。

> 索引和快照级别隔离
1. 索引直接指向对象的所有版本，然后在需要时过滤掉不可见的版本
2. 把同一对象的不同版本放在一个内存页上。
3. 索引主体是B-Tree，采用追加、写时复制的技术，当需要更新时，不修改现有页面，而是创建一个新的修改副本，拷贝必要内容，然后让父节点，或者递归向上直到树的root节点都指向新创建的节点，不受影响的页面则不需要更新。这样每个事务都会创建一个新的B-tree root节点，代表该时刻数据库的一致性快照。避免了过滤。


#### 防止更新丢失

应用从数据库读出一个值，根据逻辑修改后，写回数据库，并发导致丢失。

1. 通过原子写操作解决：乐观锁
2. 显式加锁：应用显式锁定待更新的对象：for update
3. 自动检测更新丢失：先让他们并发的执行，如果事务管理器发现了更新丢失，则中止当前事务，并回退到安全的 读-修改-写回方式。mysql不支持该操作。
4. 原子比较与更新
5. 冲突解决和复制：多副本并发时出时采用最后写入获胜的方式

#### 写倾斜与幻读

写倾斜：两个事务读取相同的一组对象，然后更新其中一部分；不同的事务可能更新不同的对象，可能发生写倾斜。

方案：
1. 采用for update 加锁，但是未查询到数据无法加锁
2. 实体化冲突，将数据提前实体化，不建议采用
3. 串行化

#### 两阶段加锁

一种被广泛使用的串行化算法。
1. 事务A读取了某个值，事务B想要写入该对象，B必须等到A提交或中止才能继续。
2. 事务A修改了对象，事务B想要读取该对象，B必须等到A提交或中止后才能继续。

实现方式：

数据库每个对象都有一个读写锁来隔离读写操作。

性能堪忧

> 谓词锁

1. 如果事务A想要读取某些满足匹配条件的对象，必须以共享模式获取查询条件的谓词锁，如果另一个事务B正持有任何一个匹配对象的互斥锁，那么A必须等待B释放。
2. 如果事务A想要插入，更新或者删除对象，必须检查所有旧值和新值是否与现有的任何谓词锁匹配，如果事务B持有这样的锁，则A等待B释放锁

谓词锁可以保护那些尚不存在，但可能马上插入的对象（幻读），将两阶段加锁与谓词锁结合使用，数据库可以防止所有形式的写倾斜以及其他竞争条件，隔离变得正真可串行化

> 索引区间锁

谓词锁性能不佳，因此大量2PC数据库采用索引区间锁（next-key locking）。

扩大化的谓词锁，扩大加锁区间，简化加锁开销。




